2일차=======================================================================
＃형변환
-자동형변환 : 컴파일러가 자동으로 작은자료형을 큰자료형으로 변환
-강제형변환 : 큰자료형에서 작은 자료형으로 변환시 데이터손실이 발생할수있음(데이터의 변형,손실 감수)
#변수와 메모리 구조
-static = 메소드가 저장되는 공간
#출력메소드
-printf() = 정해져 있는 형식에 맞춰서 그 형식에 맞는 값을 줄바꿈 하지 않고 출력 [잘안씀]
#escape 문자
-\   + 	t=tap (출력에 표기)
	n=엔터
	\=\
	'='
	"="
	u-유니코드표시
=============================
1.변수
 - 변수를 선언할 수 있다.

 -변수 선언 방법
 -자료형
 -변수명 작성 규칙과 관례
 -Scanner
 -sysout

2.연산자
 -연산자 종류를 알고, 결과를 예측할 수 있다.
================================
#연산자
 -증감연산자 : ++,--
 -전위연산 : 먼저 연산 후 다른 연산 실행
 -후위연산 : 다른 연산 우선 실행 후 연산

 -산술연산자 :+,-,*,/,%(나머지연산자)
	    /를 사용할시 정수인가 고민하고 작업하기
	    /:정수/정수 =>정수
	    /,% : 2번째 수는 0이 오면 안됨.
	    % : 나누었을때 나머지 값
 -비교연산자(==,!=<=,>=,<,>) : 항상 논리값이 결과 값임
 -논리연산자 : && : 둘다 참이면 참, ~이고
	     || : 둘다 거짓이면 거짓, ~이거나
	     ! : 반대, ~아닌
 -대입연산자 : 오른쪽에 있는 값을 왼쪽에 저장 ex) a=2 ,2 =a(오류), a= 1+b, a+1 =b(오류)
 -삼항연산자 : 조건식? 참 : 거짓; 조건식의 결과 값에 따라 참일경우 식1,거짓일 경우 식2 수행
	     ex)String str = a>b ? "참" : "거짓";
 -비트연산자 : &, |, ~, ^(배타논리, xor)
	& : 1을 참, 0을 거짓으로 본다
	a>>b :a를 비트로 나열한 후 오른쪽으로 b비트만큼 이동,
	        a의 b제곱으로 나눈 효과
 	 <<   :a의b제곱으로 곱한 효과
3일차======================================================================
#조건문★★★★★★★★
	-if(조건식){실행문;}일반적으로 비교연산자가 들어감
	-if~else
		if(조건식){실행문;}else{실행문2;}//실행문이 거짓일시 실행문2 실행
		if(조건식){실행문;}else if(조건식2){}//else if문을 사용할시 조건식을 계속 추가가능
#switch문	
	-switch문 사용하는 경우
		1. 식의 값이 제한적일 때 : %연산자 이용하는 경우
		2. 사용하는 변수 값이 제한적일 때 : 산술연산자를 이용한 계산 예제	
#반복문	
	-for(초기식; 조건식; 증감식){수행될문장;}//수행식 안에 조건문을 첨가하여 조건식 가능(if)

04일차========================================================================
#중첩반복문
	-for(초기식; 조건식; 증감식){수행될문장; 
		for(초기식2; 조건식2; 증감식2){수행될문장2}}
#분기문
	-break : break문 자신이 포함된 가까운 반복문을 빠져나감(if안에서 자주씀)
	-continue : continue아래 부분은 실행하지 않고 반복문 다시실행	
배운것 정리===================================================	
	1.변수
	-변수 선언을 할 수 있다.
	-변수 선언 방법
	자료형 변수명;
	자료형 변수명=초기값;
	-자료형 종류
	-변수명 작성 규칙과 관례
	-자료형 변환 
	 -자동/강제 형변환
	-Scanner 사용 방법 : 콘솔에서 입력
	-sysout 사용 방법 : 콘솔에 출력
	2.연산자
	-연산자 종류를 알고, 결과를 예측할 수 있다.
	-연산자 종류
	-산술
		% : 나누었을 떄 나머지
		/ : 정수 /정수=>정수,1/2=>0
	-비교
		대입연산자 == 를 구별, >=와 <=기호를 =>이나=<로 잘못쓰지 말자
	-논리
		결과가 참 또는 거짓=>조건식
		연산자 양 쪽에 조건식
		&& : ~하고, 둘다 참이면 참
		|| : ~이거나, 하나라도 참이면 참
	-증감
		최종적으로 1증가
		전위 : 증가 후 동작
		후위 : 동작 후 증가
	-조건선택
		조건식?참:거짓;
	-비트논리(잘 사용안함)
	-비트쉬프트(잘 사용안함)
	-대입★
		오른쪽에 있는 값을 왼쪽에 저장(덮어쓰기)
		연산자 우선순위 : 모르면()
	3.조건문
	-조건에 따라 결과가 달라지는 상황에서 조건문을 쓸 수 있다.
	-~이면...해라
	-if문
		모든 조건문은 if문으로 표현 가능
		if(조건식){실행문;}
		-~이면 : 조건식, ...해라 : 실행문
		//조건식1이 참이면 실행문1을 실행
		if(조건식1){실행문1}
		//(조선식1이 거짓이고)조건식2가 참이면 실행문2를 실행
		else if(조건식2){실행문2;}
		//(조건식1과 조건식2가 거짓이면)실행문3을 실행
		else{실행문3]
	-switch문
		switch(식또는변수){
		case 값1: 실행문1; break;
		case 값2: 실행문2; break;
		default: 실행문3
	4.반복문
	-규칙적인 작업을 반복적으로 할 때 반복문을 사용할 수 있다.
	-반복문은 조건식이 거짓이 되는 순간 반복문을 종료
	-for문
		for(1.초기화;2.5.8조건식;4.7.증감식){3.6.실행문}
		-1.초기화 : 조건식에서 사용하는 변수를 초기화, 생략 가능,여러 변수를 초기화
		-2.조건식 : 반복문이 실행되는 곳으로 거짓이면 종료,생략 가능,생략시 항상 참
		-4.증감식 : 조건식에서 사용하는 변수를 증가/감속하여 반복횟수를 조절
	-중첩 반복문
		-반복문의 실행문으로 반복문이 오는 경우
	-break
		-반복문을 빠져 나오는 키워드, 반드시 if문 사용
	-continue 
		-반복문의 특정 위치로 이동하는 키워드, for문에서는 증감식, while문에서는 조건식
05일차=============================================
	-for문 : 순차적으로 증가/감소해서 반복문이 실행되어야 하는 경우
	-while문 : 특정값을 입력받아 활용하는 경우, 값이 순차적이지 않는 경우, 단순 횟수만 사용되는 경우
#배열
	-같은 자료형의 변수를 하나의 묶음으로 다루는 것
	-배열은 저장된 값이 0부터 시작
	-반복문을 이용해 변수들을 효율적으로 활용하기위해 사용
	자료형[] 배열명;
	자료형 배열명[];
	배열 바깥에 저장할수 없다는 경고문(java.lang.
	ArrayIndexOutOfBoundsException)
#배열 초기화
	-인덱스를 이용한 초기화
	-for문을 이용한 초기화
06일차==============================================
	배열 - 같은 자료형을 모아놓은 공간(같은 의미)
		-반복문으로 효율적으로 사용
		-한 배열에는 같은 종류에 값을 저장하는 게 좋다
		-arr1 : 0번지에는 사과 개수,1번지에는 나이, 2번지에는 학년
		-arr2 : 0번지엥 1번학생 국어성적, 1번지에는 2번학생 국어성적
				2번지에는 3번학생 국어성적
	변수 - 가정집
	배열 - 아파트
	- 기본 자료형으로 된 변수는 값을 저장
	- 배열은 주소를 저장
	배열 선언
	-자료형[] 배열명;
	-자료형 배열명[];
	배열 할당
		배열명 = new 자료형[크기]
	배열 선언과 동시에 할당
		자료형[]배열명 = new자료형[크기]
		자료형 배열명[] = new자료형[크기]
	배열의 시작번지는 0번지부터 크기-1번지까지 접근 가능
	배열[번지]
	
변수복수
	int num1 = 10, num2 =20
	//num1에 num2의 값을 복사
	num1 = num2
	num1 = 30
	num2;//num1에 상관없이 20
	
	배열 얕은 복사
	int arr1[]= new int[4];
	int arr2[];
	arr2 = arr1//arr1의 배열의 값을 arr2가 가져옴
	arr2[0] =4;
	arr1[0];//4로 같이 바뀜
	
	배열 깊은 복사
	system.arraycopy(arr1,0,arr2,0,arr1.length);
07일차==========================================
